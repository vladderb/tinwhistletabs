<!DOCTYPE html>
<html>
<head>
    <title>Sheet Music</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <style>
        @font-face {
            font-family: 'TinWhistleTab';
            src: url('tinwhistletab.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: block;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: white;
            overflow-x: hidden;
            padding-bottom: 200px;
            min-height: 100vh;
        }
        #title {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            padding: 20px 10px 10px 10px;
        }
        #paper {
            width: 100%;
            overflow: visible;
            min-height: 100%;
        }
        .staff-line {
            overflow: visible;
            margin-bottom: 0px;
        }
        svg {
            width: 100%;
            display: block;
            overflow: visible;
        }
        .abcjs-note {
            cursor: pointer;
        }
        .abcjs-note.highlight,
        .highlight path,
        .highlight circle,
        .highlight rect,
        .highlight line,
        path.highlight,
        circle.highlight,
        rect.highlight,
        line.highlight {
            fill: #FF883E !important;
            stroke: #FF883E !important;
        }
        .abcjs-lyric.highlight {
            fill: #FF883E !important;
        }
        .abcjs-lyric {
            font-family: 'TinWhistleTab', sans-serif !important;
            font-size: 40px !important;
            font-weight: normal !important;
            font-style: normal !important;
            font-variant: normal !important;
            text-rendering: geometricPrecision !important;
            -webkit-font-smoothing: none !important;
            -moz-osx-font-smoothing: unset !important;
        }
        /* Disable ABCJS default red click highlight */
        .abcjs-note_selected,
        .abcjs-note_selected path,
        .abcjs-note_selected circle,
        .abcjs-note_selected rect,
        .abcjs-note_selected line {
            fill: inherit !important;
            stroke: inherit !important;
        }
    </style>
</head>
<body>
<div id="title"></div>
<div id="paper"></div>
<script src="abcjs_basic_6.5.1-min.js"></script>
<script>
if (typeof abcjs !== 'undefined' && typeof ABCJS === 'undefined') {
    window.ABCJS = abcjs;
}

var visualObj = null;
var currentNoteIndex = -1;
var startNoteIndex = 0;
var isPlaying = false;

var pitchToTab = {
    54: 'd', 55: 'i', 56: 'e', 57: 'j', 58: 'f', 59: 'g', 60: 'h', 61: 'a',
    62: 'n', 63: 'b', 64: 'm', 65: 'c', 66: 'D', 67: 'I', 68: 'E', 69: 'J',
    70: 'F', 71: 'G', 72: 'H', 73: 'A', 74: 'N', 75: 'B', 76: 'M', 77: 'C',
    78: '\u00CE'
};

function abcNoteToPitch(abcNote, keySignature) {
    var originalNote = abcNote;
    var note = abcNote;
    
    // Check for explicit accidentals at the start
    var hasExplicitAccidental = false;
    var accidentalOffset = 0;
    var baseNote = '';
    
    if (note.startsWith('^')) {
        hasExplicitAccidental = true;
        accidentalOffset = 1; // Sharp
        baseNote = note.charAt(1);
    } else if (note.startsWith('_')) {
        hasExplicitAccidental = true;
        accidentalOffset = -1; // Flat
        baseNote = note.charAt(1);
    } else if (note.startsWith('=')) {
        hasExplicitAccidental = true;
        accidentalOffset = 0; // Natural (cancels key signature)
        baseNote = note.charAt(1);
    } else {
        baseNote = note.charAt(0);
    }
    
    // Get base pitch (C=0, D=2, E=4, F=5, G=7, A=9, B=11)
    var baseNoteLower = baseNote.toLowerCase();
    var notePitches = {
        'c': 0, 'd': 2, 'e': 4, 'f': 5, 'g': 7, 'a': 9, 'b': 11
    };
    var pitch = notePitches[baseNoteLower];
    if (pitch === undefined) {
        console.error('Invalid note:', abcNote);
        return 0;
    }
    
    // Apply explicit accidental
    pitch += accidentalOffset;
    
    // Apply key signature if no explicit accidental
    if (!hasExplicitAccidental && keySignature) {
        var baseNoteUpper = baseNote.toUpperCase();
        if (keySignature[baseNoteUpper] === 1) {
            pitch += 1; // Sharp from key
        } else if (keySignature[baseNoteUpper] === -1) {
            pitch -= 1; // Flat from key
        }
    }
    
    // Determine octave: uppercase = octave 4, lowercase = octave 5
    var octave;
    if (baseNote >= 'A' && baseNote <= 'G') {
        octave = 4; // Uppercase
    } else {
        octave = 5; // Lowercase
    }
    
    // Count apostrophes (raise octave) and commas (lower octave)
    var apostrophes = (note.match(/'/g) || []).length;
    var commas = (note.match(/,/g) || []).length;
    octave += apostrophes - commas;
    
    // Convert to MIDI pitch: C4 = 60
    // Formula: pitch + (octave * 12)
    // C4 = 0 + (4 * 12) = 48, but MIDI C4 = 60, so we add 12
    var midiPitch = pitch + (octave * 12) + 12;
    
    // Convert MIDI to project pitch (subtract 20)
    var projectPitch = midiPitch - 20;
    
    console.log('ABC:', abcNote, '-> base:', baseNote, 'pitch:', pitch, 'octave:', octave, 'MIDI:', midiPitch, 'project:', projectPitch);
    
    return projectPitch;
}

function getKeySignature(key) {
    var signature = {};
    var normalizedKey = key.toUpperCase().trim();
    
    // Minor keys (check first)
    if (normalizedKey.indexOf('MINOR') >= 0 || normalizedKey.indexOf('MIN') >= 0 || normalizedKey.indexOf('M') === normalizedKey.length - 1) {
        if (normalizedKey.indexOf('E') === 0) {
            // E minor = 1 sharp: F#
            signature['F'] = 1;
        } else if (normalizedKey.indexOf('B') === 0) {
            // B minor = 2 sharps: F#, C#
            signature['F'] = 1;
            signature['C'] = 1;
        } else if (normalizedKey.indexOf('A') === 0) {
            // A minor = no sharps/flats
        } else if (normalizedKey.indexOf('D') === 0) {
            // D minor = 1 flat: Bb
            signature['B'] = -1;
        }
    } else {
        // Major keys
        if (normalizedKey.indexOf('G') === 0) {
            // G major = 1 sharp: F#
            signature['F'] = 1;
        } else if (normalizedKey.indexOf('D') === 0) {
            // D major = 2 sharps: F#, C#
            signature['F'] = 1;
            signature['C'] = 1;
        } else if (normalizedKey.indexOf('A') === 0) {
            // A major = 3 sharps: F#, C#, G#
            signature['F'] = 1;
            signature['C'] = 1;
            signature['G'] = 1;
        } else if (normalizedKey.indexOf('E') === 0) {
            // E major = 4 sharps: F#, C#, G#, D#
            signature['F'] = 1;
            signature['C'] = 1;
            signature['G'] = 1;
            signature['D'] = 1;
        } else if (normalizedKey.indexOf('B') === 0) {
            // B major = 5 sharps: F#, C#, G#, D#, A#
            signature['F'] = 1;
            signature['C'] = 1;
            signature['G'] = 1;
            signature['D'] = 1;
            signature['A'] = 1;
        } else if (normalizedKey.indexOf('F') === 0) {
            // F major = 1 flat: Bb
            signature['B'] = -1;
        }
    }
    
    return signature;
}

function expandRepeats(abcString) {
    var lines = abcString.split('\n');
    var result = [];
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var cleanedLine = line.replace(/\|:/g, '|').replace(/:\|/g, '|').replace(/::/g, '|');
        result.push(cleanedLine);
    }
    return result.join('\n');
}

function hasHalfHoled(pitches, shift, halfHoled) {
    for (var i = 0; i < pitches.length; i++) {
        var transposedPitch = pitches[i] + shift;
        for (var j = 0; j < halfHoled.length; j++) {
            if (transposedPitch === halfHoled[j]) {
                return true;
            }
        }
    }
    return false;
}

function autoTranspose(pitches) {
    if (pitches.length === 0) return 0;
    
    var min = Math.min.apply(null, pitches);
    var max = Math.max.apply(null, pitches);
    var whistleMin = 54;
    var whistleMax = 78;
    
    // Half-holed notes (chromatic notes) - same as in ABCParser.java
    var halfHoled = [55, 57, 60, 62, 64, 67, 69, 72, 74, 76];
    
    // First try without half-holed notes
    
    // If already in range and no half-holed notes
    if (min >= whistleMin && max <= whistleMax) {
        if (!hasHalfHoled(pitches, 0, halfHoled)) {
            console.log('No transpose needed, no half-holes');
            return 0;
        }
    }
    
    // Try octave up (+12)
    if (min + 12 >= whistleMin && max + 12 <= whistleMax) {
        if (!hasHalfHoled(pitches, 12, halfHoled)) {
            console.log('Transpose +12 (octave up), no half-holes');
            return 12;
        }
    }
    
    // Try octave down (-12)
    if (min - 12 >= whistleMin && max - 12 <= whistleMax) {
        if (!hasHalfHoled(pitches, -12, halfHoled)) {
            console.log('Transpose -12 (octave down), no half-holes');
            return -12;
        }
    }
    
    // Automatic semitone search - start from 0 and go up
    var shift = 0;
    while (max + shift <= whistleMax) {
        if (min + shift >= whistleMin && max + shift <= whistleMax) {
            if (!hasHalfHoled(pitches, shift, halfHoled)) {
                if (shift !== 0 && shift !== 12 && shift !== -12) {
                    console.log('Warning: shift is not perfect octave (' + shift + ')');
                }
                return shift;
            }
        }
        shift++;
    }
    
    // If no suitable transposition found without half-holes, allow them
    console.warn('Could not find transposition without half-holed notes, allowing them');
    
    if (min >= whistleMin && max <= whistleMax) {
        return 0;
    }
    
    if (min + 12 >= whistleMin && max + 12 <= whistleMax) {
        return 12;
    }
    
    if (min - 12 >= whistleMin && max - 12 <= whistleMax) {
        return -12;
    }
    
    for (shift = -24; shift <= 24; shift++) {
        if (min + shift >= whistleMin && max + shift <= whistleMax) {
            return shift;
        }
    }
    
    return 0; // No suitable transposition found
}

function renderMusicWithTab(abcString, tablature) {
    console.log('=== JS TAB RENDERING ===');
    console.log('Tablature provided:', tablature ? 'YES (' + tablature.length + ' chars)' : 'NO');
    if (tablature) {
        console.log('Tablature content (first 100 chars):', tablature.substring(0, 100));
        console.log('Tablature content (last 50 chars):', tablature.substring(Math.max(0, tablature.length - 50)));
        
        // LOG: Show first 20 tab characters with their char codes
        var tabCharsPreview = [];
        var charCount = 0;
        for (var i = 0; i < tablature.length && charCount < 20; i++) {
            var ch = tablature.charAt(i);
            if (ch !== ' ') {
                tabCharsPreview.push('Tab #' + (charCount + 1) + ': "' + ch + '" (code: ' + ch.charCodeAt(0) + ')');
                charCount++;
            }
        }
        console.log('First 20 tabs:', tabCharsPreview.join(', '));
    }
    
    var expandedABC = expandRepeats(abcString);
    var lines = expandedABC.split('\n');
    var header = [];
    var musicLines = [];
    var inMusic = false;
    var title = '';
    var keySignature = {};
    
    // Extract key signature
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        if (line.match(/^K:/)) {
            var key = line.substring(2).trim().split(/\s+/)[0];
            keySignature = getKeySignature(key);
            console.log('Key signature:', key, keySignature);
            break;
        }
    }
    
    // First pass: collect all pitches to determine transposition
    var allPitches = [];
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        if (line.length > 0 && !line.match(/^[A-Z]:/) && !line.match(/^%/) && !line.match(/^w:/)) {
            // Match notes with optional accidentals, octave marks, and durations
            var notePattern = /[\^_=]?[A-Ga-gz][',]*[0-9/]*/g;
            var match;
            while ((match = notePattern.exec(line)) !== null) {
                var fullNote = match[0];
                // Remove duration markers to get just the note
                var abcNote = fullNote.replace(/[0-9/]/g, '');
                if (abcNote !== 'z' && abcNote !== 'Z' && abcNote !== '') {
                    var pitch = abcNoteToPitch(abcNote, keySignature);
                    allPitches.push(pitch);
                    console.log('Collected note:', fullNote, '->', abcNote, '-> pitch:', pitch);
                }
            }
        }
    }
    
    console.log('Total notes collected:', allPitches.length);
    
    // Parse tablature from Java first
    var tabChars = [];
    if (tablature) {
        for (var t = 0; t < tablature.length; t++) {
            var ch = tablature.charAt(t);
            if (ch !== ' ') {
                tabChars.push(ch);
            }
        }
        console.log('Total tabs available:', tabChars.length);
        console.log('First 20 tabs:', tabChars.slice(0, 20).join(''));
    }
    
    // IMPORTANT: If tablature is provided from Java, DO NOT transpose!
    // Java already provides correctly transposed tabs
    var transposeShift = 0;
    if (tabChars.length === 0) {
        // Only auto-transpose if we're generating tabs from ABC (no Java tabs)
        if (allPitches.length > 0) {
            transposeShift = autoTranspose(allPitches);
            console.log('Auto-transpose shift:', transposeShift, 'pitches range:', Math.min.apply(null, allPitches), '-', Math.max.apply(null, allPitches));
            if (transposeShift !== 0) {
                console.log('After transpose:', Math.min.apply(null, allPitches) + transposeShift, '-', Math.max.apply(null, allPitches) + transposeShift);
            }
        } else {
            console.warn('No notes collected for transposition!');
        }
    } else {
        console.log('Tabs provided from Java - skipping auto-transpose (Java already transposed)');
    }
    var tabIndex = 0;
    var totalNotesInABC = 0;
    
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        
        if (line.match(/^T:/)) {
            title = line.substring(2).trim();
            continue;
        }
        
        if (!inMusic) {
            header.push(lines[i]);
            if (line.match(/^K:/)) {
                inMusic = true;
            }
        } else if (line.length > 0 && !line.match(/^[A-Z]:/) && !line.match(/^%/) && !line.match(/^w:/)) {
            if (tabChars.length > 0 && tabIndex >= tabChars.length) {
                break;
            }
            
            var tabLine = 'w:';
            // Match notes with optional accidentals, octave marks, and durations
            var notePattern = /[\^_=]?[A-Ga-gz][',]*[0-9/]*/g;
            var match;
            
            while ((match = notePattern.exec(line)) !== null) {
                var fullNote = match[0];
                // Remove duration markers to get just the note
                var abcNote = fullNote.replace(/[0-9/]/g, '');
                
                if (abcNote === '' || abcNote === ' ') {
                    continue;
                }
                
                // Always use provided tablature if available
                if (tabChars.length > 0 && tabIndex < tabChars.length) {
                    // Skip rests in ABC, but still consume tabs for non-rests
                    if (abcNote !== 'z' && abcNote !== 'Z') {
                        totalNotesInABC++;
                        var tabChar = tabChars[tabIndex];
                        if (totalNotesInABC <= 20) {
                            console.log('TAB_APPLY #' + totalNotesInABC + ': ABC="' + fullNote + '" -> tab="' + tabChar + '" (code: ' + tabChar.charCodeAt(0) + ', tabIndex: ' + tabIndex + ')');
                        }
                        tabLine += tabChar + ' ';
                        tabIndex++;
                    } else {
                        console.log('ABC note:', fullNote, '-> rest (skipped)');
                    }
                } else if (tabChars.length === 0) {
                    // Fallback: generate tablature from ABC notes only if no tabs provided
                    // In this case, transposeShift is calculated above
                    if (abcNote === 'z' || abcNote === 'Z') {
                        tabLine += '- ';
                    } else {
                        var pitch = abcNoteToPitch(abcNote, keySignature) + transposeShift;
                        var tab = pitchToTab[pitch] || '?';
                        console.log('Fallback tab generation: ABC=' + abcNote + ', pitch=' + pitch + ', tab=' + tab);
                        tabLine += tab + ' ';
                    }
                } else {
                    // Ran out of tabs but still have notes - this is an error
                    console.error('Ran out of tabs at note:', fullNote, 'tabIndex:', tabIndex, 'total tabs:', tabChars.length);
                }
            }
            
            musicLines.push({music: lines[i], tab: tabLine});
        }
    }
    
    console.log('Total notes found in ABC:', totalNotesInABC);
    console.log('Total tabs used:', tabIndex);
    console.log('Tabs remaining:', tabChars.length - tabIndex);
    
    // Show alert for debugging
    if (tabChars.length > 0) {
        var msg = 'Tabs: ' + tabChars.length + ', Notes in ABC: ' + totalNotesInABC + ', Used: ' + tabIndex;
        console.log('DEBUG: ' + msg);
        // Uncomment to show alert: alert(msg);
    }
    
    if (title) {
        document.getElementById('title').textContent = title;
    }
    
    document.getElementById('paper').innerHTML = '';
    
    visualObj = [];
    
    var keyLine = '';
    for (var h = 0; h < header.length; h++) {
        if (header[h].trim().match(/^K:/)) {
            keyLine = header[h];
            break;
        }
    }
    
    for (var i = 0; i < musicLines.length; i++) {
        var lineDiv = document.createElement('div');
        lineDiv.className = 'staff-line';
        lineDiv.style.marginBottom = '0px';
        lineDiv.style.overflow = 'visible';
        lineDiv.id = 'staff-' + i;
        document.getElementById('paper').appendChild(lineDiv);
        
        var lineABC;
        if (i === 0) {
            lineABC = header.join('\n') + '\n' + musicLines[i].music + '\n' + musicLines[i].tab;
        } else {
            lineABC = 'X:1\n' + keyLine + '\n' + musicLines[i].music + '\n' + musicLines[i].tab;
        }
        
        var lineObj = ABCJS.renderAbc('staff-' + i, lineABC, {
            responsive: "resize",
            add_classes: true,
            scale: 1.0,
            staffwidth: window.innerWidth - 20,
            selectionColor: "transparent",
            format: {
                vocalfont: "TinWhistleTab 40px",
                vocalspace: 50,
                staffbottom: 100
            },
            clickListener: function(abcElem, tuneNumber, classes, analysis, drag, mouseEvent) {
                if (mouseEvent) {
                    mouseEvent.preventDefault();
                    mouseEvent.stopPropagation();
                }
                if (abcElem) {
                    var noteIndex = findNoteIndex(abcElem);
                    if (noteIndex >= 0) {
                        Android.onNoteClicked(noteIndex);
                    }
                }
                return false;
            }
        });
        
        if (lineObj && lineObj[0]) {
            visualObj.push(lineObj[0]);
        }
    }
    
    console.log('Rendered ' + musicLines.length + ' separate staff lines');
    
    setTimeout(function() {
        forceRenderAllContent();
    }, 100);
}

function forceRenderAllContent() {
    var allSvgs = document.querySelectorAll('svg');
    console.log('Forcing render of ' + allSvgs.length + ' SVGs');
    
    allSvgs.forEach(function(svg, index) {
        svg.removeAttribute('viewBox');
        
        var maxY = 0;
        var maxX = 0;
        var minY = 999999;
        
        try {
            var allElements = svg.querySelectorAll('*');
            allElements.forEach(function(elem) {
                try {
                    var bbox = elem.getBBox();
                    if (bbox.height > 0 && bbox.width > 0) {
                        maxY = Math.max(maxY, bbox.y + bbox.height);
                        maxX = Math.max(maxX, bbox.x + bbox.width);
                        minY = Math.min(minY, bbox.y);
                    }
                } catch (e) {}
            });
            
            // Calculate actual content height
            var contentHeight = maxY - minY;
            var svgHeight = contentHeight + 50; // Fixed padding
            var svgWidth = maxX + 20;
            
            // Use viewBox starting from minY to crop empty space at top
            svg.setAttribute('viewBox', '0 ' + (minY - 10) + ' ' + svgWidth + ' ' + svgHeight);
            svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');
            svg.removeAttribute('width');
            svg.removeAttribute('height');
            svg.style.width = '100%';
            svg.style.height = 'auto';
            
            console.log('SVG ' + index + ': viewBox 0 ' + (minY - 10) + ' ' + svgWidth + ' ' + svgHeight);
            
            // Multiple forced repaints
            svg.style.transform = 'translateZ(0)';
            svg.style.willChange = 'transform';
            svg.offsetHeight;
            svg.getBoundingClientRect();
            svg.style.transform = '';
            svg.style.willChange = 'auto';
        } catch (e) {
            console.error('Error processing SVG ' + index + ':', e);
        }
    });
    
    // Force all parent divs to render
    var allDivs = document.querySelectorAll('.staff-line');
    allDivs.forEach(function(div) {
        div.style.transform = 'translateZ(0)';
        div.offsetHeight;
        div.getBoundingClientRect();
        div.style.transform = '';
    });
    
    document.body.style.minHeight = 'auto';
    var bodyHeight = document.body.scrollHeight;
    document.body.style.minHeight = bodyHeight + 'px';
    
    console.log('Forced render complete, body height: ' + bodyHeight + 'px');
    
    // Additional forced render after delay
    setTimeout(function() {
        console.log('Second render pass');
        allSvgs.forEach(function(svg) {
            svg.style.opacity = '0.99';
            svg.offsetHeight;
            svg.style.opacity = '1';
        });
    }, 200);
    
    // Third pass - scroll to bottom and back
    setTimeout(function() {
        console.log('Third render pass - scroll trick');
        var oldScroll = window.pageYOffset;
        window.scrollTo(0, document.body.scrollHeight);
        setTimeout(function() {
            window.scrollTo(0, oldScroll);
            console.log('All render passes complete');
        }, 50);
    }, 400);
}

function findNoteIndex(abcElem) {
    if (!visualObj || visualObj.length === 0) return -1;
    
    var noteCount = 0;
    
    for (var objIdx = 0; objIdx < visualObj.length; objIdx++) {
        var obj = visualObj[objIdx];
        if (!obj || !obj.lines) continue;
        
        var lines = obj.lines;
        for (var i = 0; i < lines.length; i++) {
            var staff = lines[i].staff;
            if (!staff || !staff[0] || !staff[0].voices) continue;
            
            var voices = staff[0].voices;
            for (var v = 0; v < voices.length; v++) {
                var voice = voices[v];
                for (var n = 0; n < voice.length; n++) {
                    var elem = voice[n];
                    if (elem.el_type === 'note') {
                        if (elem === abcElem) {
                            return noteCount;
                        }
                        noteCount++;
                    }
                }
            }
        }
    }
    return -1;
}

function highlightNote(noteIndex) {
    if (!visualObj || visualObj.length === 0) return;
    
    // Always highlight from the beginning (0) to current note
    if (currentNoteIndex === -1 || noteIndex < currentNoteIndex) {
        startNoteIndex = 0;
    }
    currentNoteIndex = noteIndex;
    
    var allNotes = document.querySelectorAll('.abcjs-note, .abcjs-lyric');
    allNotes.forEach(function(note) {
        note.classList.remove('highlight');
    });
    
    var currentCount = 0;
    
    for (var objIdx = 0; objIdx < visualObj.length; objIdx++) {
        var obj = visualObj[objIdx];
        if (!obj || !obj.lines) continue;
        
        var lines = obj.lines;
        for (var i = 0; i < lines.length; i++) {
            var staff = lines[i].staff;
            if (!staff || !staff[0] || !staff[0].voices) continue;
            
            var voices = staff[0].voices;
            for (var v = 0; v < voices.length; v++) {
                var voice = voices[v];
                
                for (var n = 0; n < voice.length; n++) {
                    var elem = voice[n];
                    if (elem.el_type === 'note') {
                        if (currentCount >= startNoteIndex && currentCount <= noteIndex && elem.abselem) {
                            if (elem.abselem.elemset && elem.abselem.elemset.length > 0) {
                                elem.abselem.elemset.forEach(function(svgElem) {
                                    if (svgElem.classList) {
                                        svgElem.classList.add('highlight');
                                    }
                                });
                            }
                            if (elem.lyric && elem.lyric.length > 0) {
                                elem.lyric.forEach(function(lyric) {
                                    if (lyric.abselem && lyric.abselem.elemset) {
                                        lyric.abselem.elemset.forEach(function(svgElem) {
                                            if (svgElem.classList) {
                                                svgElem.classList.add('highlight');
                                            }
                                        });
                                    }
                                });
                            }
                        }
                        currentCount++;
                    }
                }
            }
        }
    }
    
    // Highlight beams for highlighted notes
    var allSvgs = document.querySelectorAll('svg');
    allSvgs.forEach(function(svg) {
        // Get highlighted notes only in this SVG
        var highlightedNotesInSvg = svg.querySelectorAll('.abcjs-note.highlight');
        if (highlightedNotesInSvg.length === 0) return;
        
        var allPaths = svg.querySelectorAll('path');
        allPaths.forEach(function(path) {
            try {
                var bbox = path.getBBox();
                // Beams are wide horizontal paths
                if (bbox.width > bbox.height * 2 && bbox.height >= 3 && bbox.height < 15 && bbox.width < 200) {
                    var beamLeft = bbox.x;
                    var beamRight = bbox.x + bbox.width;
                    var beamY = bbox.y;
                    
                    var hasNoteInBeam = false;
                    
                    for (var i = 0; i < highlightedNotesInSvg.length; i++) {
                        try {
                            var noteBbox = highlightedNotesInSvg[i].getBBox();
                            var noteX = noteBbox.x + noteBbox.width / 2;
                            var noteY = noteBbox.y;
                            var noteBottom = noteBbox.y + noteBbox.height;
                            
                            // Check if note is connected to this beam (above or below)
                            if (noteX >= beamLeft - 10 && noteX <= beamRight + 10) {
                                // Beam can be above notes (normal) or below notes (inverted)
                                var distanceFromTop = Math.abs(beamY - noteY);
                                var distanceFromBottom = Math.abs(beamY - noteBottom);
                                if (distanceFromTop < 50 || distanceFromBottom < 50) {
                                    hasNoteInBeam = true;
                                    break;
                                }
                            }
                        } catch (e) {}
                    }
                    
                    if (hasNoteInBeam) {
                        path.classList.add('highlight');
                        path.style.fill = '#FF883E';
                        path.style.stroke = '#FF883E';
                    }
                }
            } catch (e) {}
        });
    });
    
    // Scroll to current note if playing
    scrollToNote(noteIndex);
}

function clearHighlight() {
    currentNoteIndex = -1;
    startNoteIndex = 0;
    
    var allHighlighted = document.querySelectorAll('.highlight');
    allHighlighted.forEach(function(elem) {
        elem.classList.remove('highlight');
    });
    
    // Clear beam styles
    var allSvgs = document.querySelectorAll('svg');
    allSvgs.forEach(function(svg) {
        var allPaths = svg.querySelectorAll('path');
        allPaths.forEach(function(path) {
            if (path.style.fill === 'rgb(255, 136, 62)' || path.style.fill === '#FF883E') {
                path.style.fill = '';
                path.style.stroke = '';
            }
        });
    });
}

function setPlayingMode(playing) {
    isPlaying = playing;
    console.log('Playing mode: ' + isPlaying);
}

function scrollToNote(noteIndex) {
    if (!isPlaying) {
        console.log('Not playing, skip scroll');
        return;
    }
    
    if (!visualObj || visualObj.length === 0) return;
    
    // Find which staff line contains this note
    var currentCount = 0;
    var targetStaffIndex = -1;
    
    for (var objIdx = 0; objIdx < visualObj.length; objIdx++) {
        var obj = visualObj[objIdx];
        if (!obj || !obj.lines) continue;
        
        var lines = obj.lines;
        for (var i = 0; i < lines.length; i++) {
            var staff = lines[i].staff;
            if (!staff || !staff[0] || !staff[0].voices) continue;
            
            var voices = staff[0].voices;
            for (var v = 0; v < voices.length; v++) {
                var voice = voices[v];
                for (var n = 0; n < voice.length; n++) {
                    var elem = voice[n];
                    if (elem.el_type === 'note') {
                        if (currentCount === noteIndex) {
                            targetStaffIndex = objIdx;
                            break;
                        }
                        currentCount++;
                    }
                }
                if (targetStaffIndex >= 0) break;
            }
            if (targetStaffIndex >= 0) break;
        }
        if (targetStaffIndex >= 0) break;
    }
    
    if (targetStaffIndex >= 0) {
        var staffDiv = document.getElementById('staff-' + targetStaffIndex);
        if (staffDiv) {
            try {
                var rect = staffDiv.getBoundingClientRect();
                var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                var elementTop = rect.top + scrollTop;
                var windowHeight = window.innerHeight;
                var scrollTo = elementTop - 50; // Small offset from top
                
                window.scrollTo({
                    top: scrollTo,
                    behavior: 'smooth'
                });
                
                console.log('Scrolled to staff line ' + targetStaffIndex);
            } catch (e) {
                console.error('Error scrolling to staff:', e);
            }
        }
    }
}
</script>
</html>
